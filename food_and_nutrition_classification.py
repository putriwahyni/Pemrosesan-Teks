# -*- coding: utf-8 -*-
"""Food and Nutrition Classification

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zeXdUfg0u79LuuPvJAWPD2KQvXHWahxU
"""

import os
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

data=pd.read_csv('Food and Nutrition.csv')

data

"""Feature enginering"""

data['BMI'] = data['Weight'] / (data['Height'] / 100) ** 2

data['Calories_Age_Ratio'] = data['Daily Calorie Target'] / data['Ages']

sns.scatterplot(data=data,x='BMI',y='Calories_Age_Ratio',hue='Gender')

from scipy.stats import ttest_ind

male_calories = data[data['Gender'] == 'Male']['Daily Calorie Target']
female_calories = data[data['Gender'] == 'Female']['Daily Calorie Target']

t_stat, p_value = ttest_ind(male_calories, female_calories)
print(f'T-Statistic: {t_stat}, P-Value: {p_value}')

!pip install squarify

import squarify

gender_counts = data['Gender'].value_counts()
squarify.plot(sizes=gender_counts.values, label=gender_counts.index, alpha=0.8)
plt.axis('off')
plt.title('Gender Distribution')
plt.show()

"""Preprocessing

"""

from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import MinMaxScaler

# Endcoder

categorical = ["Gender", "Activity Level", "Dietary Preference", "Breakfast Suggestion", "Lunch Suggestion", "Dinner Suggestion", "Snack Suggestion"]
le = LabelEncoder()
for i in categorical:
    data[i] = le.fit_transform(data[i])

data

#Scalling Data
x = data.iloc[:, 0:18].values     # Feature
y = data.iloc[:, 18].values       # Label

scaler = MinMaxScaler()
x = scaler.fit_transform(x)

"""Classification"""

from sklearn.model_selection import train_test_split
from sklearn import svm
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

from sklearn.preprocessing import LabelEncoder
label_encoder = LabelEncoder()
data['Disease_encoded'] = label_encoder.fit_transform(data['Disease'])

X = data.select_dtypes(include=['int64', 'float64']).drop(columns=['Disease_encoded'])
y = data['Disease_encoded']

# Step 3: Train-test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

X_train.shape,X_test.shape

rf_model = svm.SVC(kernel='linear')
rf_model.fit(X_train, y_train)

# Step 5: Make predictions
y_pred = rf_model.predict(X_test)

from sklearn.metrics import classification_report

# Align the target names with the classes present in y_test
unique_classes = np.unique(y_test)  # Classes present in y_test
target_names = label_encoder.inverse_transform(unique_classes)  # Decode only the present classes

print("Classification Report:")
print(classification_report(y_test, y_pred, labels=unique_classes, target_names=target_names))

print("\nAccuracy Score:")
print(accuracy_score(y_test, y_pred))

sns.heatmap(confusion_matrix(y_test,y_pred),annot=True,fmt='d')